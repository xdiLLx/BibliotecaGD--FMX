unit GDEdit;

interface

uses
  System.SysUtils, System.Classes, FMX.Edit, Data.DB, GD.Types, System.Types, System.Math, FMX.Types;

type
  TGDEdit = class(TEdit)
  private
    FDataSource: TDataSource;
    FDataField: string;
    FOriginalText: string;
    FOriginalDataChange: TDataChangeEvent;
    FOnKeyDown: TKeyEvent;
    procedure SetDataSource(const Value: TDataSource);
    procedure SetDataField(const Value: string);
    procedure UpdateControlState;
    procedure UpdateData;
    procedure DataSetEvent(DataSet: TDataSet);
    procedure DataSourceChanged(Sender: TObject; Field: TField);
    function GetVersion: string;
    procedure IntermediateDataChange(Sender: TObject; Field: TField);
    procedure ValidateInput(Field: TField; var KeyChar: Char);
  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    procedure DoEnter; override;
    procedure DoExit; override;
    procedure DoTyping(Sender: TOBject;var Key: Word; var KeyChar: Char; Shift: TShiftState);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property About: String read GetVersion;
    property DataSource: TDataSource read FDataSource write SetDataSource;
    property DataField: string read FDataField write SetDataField;
    property OnKeyDown: TKeyEvent read FOnKeyDown write FOnKeyDown;
  end;

procedure register;

implementation

procedure register;
begin
  RegisterComponents('Delphi | Biblioteca GD', [TGDEdit]);
end;

constructor TGDEdit.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  ReadOnly := True;
  OnKeyDown := DoTyping;
end;

destructor TGDEdit.Destroy;
begin
  SetDataSource(nil);
  inherited Destroy;
end;

procedure TGDEdit.SetDataSource(const Value: TDataSource);
begin
  if FDataSource <> Value then
  begin
    if Assigned(FDataSource) then
    begin
      FDataSource.RemoveFreeNotification(Self);
    end;

    FDataSource := Value;

    if Assigned(FDataSource) then
    begin
      FDataSource.FreeNotification(Self);

      // Guarde o evento OnDataChange anterior
      FOriginalDataChange := FDataSource.OnDataChange;
      FDataSource.OnDataChange := IntermediateDataChange;
    end;

    UpdateControlState;
  end;
end;

procedure TGDEdit.SetDataField(const Value: string);
begin
  if FDataField <> Value then
  begin
    FDataField := Value;
    UpdateData;
  end;
end;

procedure TGDEdit.UpdateControlState;
var
  Field: TField;
begin
  Field := nil;

  if Assigned(FDataSource) and Assigned(FDataSource.DataSet) then
  begin
    Field := FDataSource.DataSet.FindField(FDataField);

    ReadOnly := not(FDataSource.DataSet.State in [dsEdit, dsInsert]) or (Field = nil);
    if Assigned(Field) then
      Text := Field.AsString
    else
      Text := '';
  end
  else
  begin
    ReadOnly := True;
    Text := '';
  end;
end;

procedure TGDEdit.UpdateData;
var
  Field: TField;
begin
  Field := nil;
  if ReadOnly and Assigned(FDataSource) and Assigned(FDataSource.DataSet) then
    Field := FDataSource.DataSet.FieldByName(FDataField);

  if Assigned(Field) then
    Text := Field.AsString
  else
    Text := '';
end;

procedure TGDEdit.ValidateInput(Field: TField; var KeyChar: Char);
begin
  case Field.DataType of
    ftInteger, ftSmallint, ftWord, ftLargeint:
      begin
        if not (Key in ['0'..'9']) then
          Key := #0;
      end;

    ftFloat, ftCurrency:
      begin
        // Permite dígitos, ponto e vírgula. Evita múltiplos pontos ou vírgulas.
        if not (Key in ['0'..'9', '.', ',']) or
           ((Key in ['.', ',']) and (Pos('.', Text) > 0) or (Pos(',', Text) > 0)) then
          Key := #0;
      end;

    ftString, ftWideString:
      begin
        // Para strings, por padrão, permitiremos qualquer caractere.
        // Mas se você quiser algum limite específico ou rejeitar caracteres especiais, defina aqui.
      end;

    ftDate:
      begin
        // Permite apenas números e o caractere de separação de data (geralmente "/").
        if not (Key in ['0'..'9', '/']) then
          Key := #0;
      end;

    ftTime:
      begin
        // Permite apenas números e o caractere de separação de hora (geralmente ":").
        if not (Key in ['0'..'9', ':']) then
          Key := #0;
      end;

    ftDateTime:
      begin
        // Para DateTime, como é uma combinação de data e hora,
        // vamos permitir números e os caracteres de separação ("/" e ":").
        if not (Key in ['0'..'9', '/', ':']) then
          Key := #0;
      end;

    // E assim por diante para outros tipos de campo, conforme necessário.

  end;
end;

procedure TGDEdit.DataSetEvent(DataSet: TDataSet);
begin
  UpdateControlState;
end;

procedure TGDEdit.DoEnter;
begin
  inherited DoEnter;
  FOriginalText := Text;
end;

procedure TGDEdit.DoExit;
var
  Field: TField;
begin
  inherited DoExit;

  if Assigned(FDataSource) and Assigned(FDataSource.DataSet) then
  begin
    Field := FDataSource.DataSet.FieldByName(FDataField);
    if (Field <> nil) and (Field.AsString <> Text) then
    begin
      Field.AsString := Text;
    end;
  end;
end;

procedure TGDEdit.DoTyping(Sender: TOBject;var Key: Word; var KeyChar: Char; Shift: TShiftState);
var
  Field: TField;
begin
  if Assigned(FDataSource) and Assigned(FDataSource.DataSet) then
  begin
    Field := FDataSource.DataSet.FieldByName(FDataField);
    if Assigned(Field) then
      ValidateInput(Field, KeyChar);
  end;
end;

function TGDEdit.GetVersion: string;
begin
  Result := GetComponentVersion;
end;

procedure TGDEdit.IntermediateDataChange(Sender: TObject; Field: TField);
begin
  if Assigned(FOriginalDataChange) then
    FOriginalDataChange(Sender, Field);

  DataSourceChanged(Sender, Field);
end;

procedure TGDEdit.Notification(AComponent: TComponent; Operation: TOperation);
begin
  inherited Notification(AComponent, Operation);
  if (Operation = opRemove) and (AComponent = FDataSource) then
    DataSource := nil;
end;

procedure TGDEdit.DataSourceChanged(Sender: TObject; Field: TField);
begin
  UpdateControlState;
end;

end.

